# Importing libraries for similarity score
from src.similarity.LowLevel.computation import compute_similarity
from src.util.helpers import *


def get_gm_parents(gm):
    """
    Get the values of the left side of the GM --> for all the parent nodes of the model

    Args:
        gm (BPMN): The generated BPMN model (generated by the AI)

    Returns:
        list: the parents' values listed
    """
    parents = []
    for edge in gm.edges:
        check_index_access(edge, 0)
        parents.append(get_value(edge[0], gm))
    return parents    
         
def get_gm_children(gm, aimed_indices):
    """
    Get the values of the right side of the GM --> for all the children nodes of the model

    Args:
        gm (BPMN): The generated BPMN model (generated by the AI)
        aimed_indices (list): List of all indices of matches on the parent side for edges in the GM

    Returns:
        list: the children' values listed
    """
    children = []
    for i in aimed_indices:
        check_index_access(gm.edges, i)
        check_index_access(gm.edges[i], 1)
        #list_edges[i][1] takes the key of the right side of a tuple, where the left side was similar
        children.append(get_value(gm.edges[i][1], gm))
    return children

def get_aimed_indices(similarity_scores, threshold):
    """
    Get the indices of the gm_list_edges with the highest similarity score 

    Args:
        similarity_scores (list): Similarity scores of one element of the SM with all elements of the GM
        threshold (int): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal

    Returns:
        list: List containing the indices of similarity_scores (therefore gm_list_edges) with the highest similarity 
    """
    
    max = 0 
    aimed_indices = []
    
    for i, similarity_score in enumerate(similarity_scores):
        
        #TODO: check for threshold and search for max --> List is used, as there could be more than 1 max
        # i.e. two exclusivegateways (x) on left side / two or more same tasks on left side
        if similarity_score > threshold and similarity_score >= max:
            if similarity_score == max:
                aimed_indices.append(i)
            else:
                aimed_indices = [i]
            max = similarity_score        
    return aimed_indices

def types_equivalent(sm_edge, gm_edge, opt_eq_map):
    """
    Check whether the types of parent/child nodes of SM and GM are equivalent, so they can be matched

    Args:
        sm_edge (list): Edge of the SM, where the first element in the list is the parent side and the second element is the children side
        gm_edge (list): Edge of the GM, where the first element in the list is the parent side and the second element is the children side
        
    Returns:
        bool: Boolean indicating whether the types are equivalent
    """
    
    check_index_access(gm_edge, 0)
    check_index_access(gm_edge, 1)
    check_index_access(sm_edge, 0)
    check_index_access(sm_edge, 1)
    return get_type(sm_edge[0]) == get_type(gm_edge[0]) and get_type(sm_edge[1]) == get_type(gm_edge[1])
             
def compare_models_em(sm, gm, weights, threshold):
    """
    Compare the two models Standard Model (SM) and Generated Model (GM) with the EdgeMatching algorithm.
    

    Args:
        sm (BPMN): The standard BPMN model (created by a human process modeler)
        gm (BPMN): The generated BPMN model (generated by the AI)
        weights (dict): Weights for the low level similarity to be applied (glove/BERT/syntactic)
        threshold (float): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal 
    """
    #format gm_list_edges correctly to compare with sm_list_edges
    gm_parents = get_gm_parents(gm)
    #print('GENERATED MODEL FORMATTED PARENTS ARE:')
    #print(gm_parents)
    opt_eq_map = []
    #iterate over entire sm_list_edges 
    for i, sm_edge in enumerate(sm.edges):
        print('****************************')
        print(f'INDEX: {i} BEGINNING')
        print('****************************')
        
        print('LEFT/PARENT SIDE')
        
        aimed_indices_parent = []
        aimed_indices_child = []
        #first compare the left side of SM and GM list_edges
        check_index_access(sm_edge, 0)
        sm_parent = get_value(sm_edge[0], sm)
        
        #similarity function (cosine, syntactic, ...) can be replaced here
        similarity_scores = compute_similarity(sm_parent, gm_parents, weights)
        #the indices of the gm_list_edges where there is a match are stored in aimed_indices_parent
        aimed_indices_parent = get_aimed_indices(similarity_scores, threshold)
        
        #no match on left side of sm at sm_edge[i] and gm
        if len(aimed_indices_parent) == 0:
            continue
           
        print('****************************')
        print(f'Aimed index is {aimed_indices_parent}')
        print('****************************')
        
        print('RIGHT/CHILD SIDE:')
        check_index_access(sm_edge, 1)
        sm_child = get_value(sm_edge[1], sm)
        
        #TODO: to be replaced by respective similarity function
        gm_children = get_gm_children(gm, aimed_indices_parent)
        similarity_scores = compute_similarity(sm_child, gm_children, weights)
        aimed_indices_child = get_aimed_indices(similarity_scores, threshold)
        print('****************************')
        
        #find true positives
        for i_right in aimed_indices_child:
            check_index_access(aimed_indices_parent, i_right)
            check_index_access(gm.edges, aimed_indices_parent[i_right])
            gm_edge = gm.edges[aimed_indices_parent[i_right]]
            #set true positives for sm and gm
            
            #the edge of the gm has no match yet (if it already has one, skip) AND the types of the matches must be equivalent (e.g. excl.gateway and parallelgateway are not the same!)
            if all(sm_edge != pair[0] for pair in opt_eq_map) and all(gm_edge != pair[1] for pair in opt_eq_map) and types_equivalent(sm_edge, gm_edge):
                opt_eq_map.append((sm_edge, gm_edge))
                print(f'MARKED INDEX {i} of SM as TRUE POSITIVE!!!!')
                print(f'CORRESPONDING INDEX {aimed_indices_parent[i_right]} OF GM TRUE POSITIVE!!!!!')
            #print('****************************')       
        print(f'INDEX: {i} ENDING')
        
    print('Final SM TUPLE:')
    print(sm.edges)
    
    print('Final GM TUPLE:')
    print(gm.edges)
    return opt_eq_map


        
    