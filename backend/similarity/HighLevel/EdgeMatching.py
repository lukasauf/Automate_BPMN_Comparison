# Importing libraries for similarity score
from backend.similarity.LowLevel.computation import compute_similarity
from helper.helpers import *


def create_gm_parents(list_edges, events, tasks, gateways):
    """
    Get the values of the left side of the GM --> for all the parent nodes of the model

    Args:
        list_edges (list): A list of lists where each list represents an edge in the BPMN model.
        events (dict): A dictionary storing keys and their corresponding values for events.
        tasks (dict): A dictionary storing keys and their corresponding values for tasks.
        gateways (dict): A dictionary storing keys and their corresponding values for gateways.

    Returns:
        list: the parents' values listed
    """
    parents = []
    for edge in list_edges:
        check_index_access(edge, 0)
        parents.append(get_value(edge[0], events, tasks, gateways))
    return parents    
         
def create_gm_children(list_edges, events, tasks, gateways, aimed_indices):
    """
    Get the values of the right side of the GM --> for all the children nodes of the model

    Args:
        list_edges (list): A list of lists where each list represents an edge in the BPMN model.
        events (dict): A dictionary storing keys and their corresponding values for events.
        tasks (dict): A dictionary storing keys and their corresponding values for tasks.
        gateways (dict): A dictionary storing keys and their corresponding values for gateways.

    Returns:
        list: the children' values listed
    """
    children = []
    for i in aimed_indices:
        check_index_access(list_edges, i)
        check_index_access(list_edges[i], 1)
        #list_edges[i][1] takes the key of the right side of a tuple, where the left side was similar
        children.append(get_value(list_edges[i][1], events, tasks, gateways))
    return children

def get_aimed_indices(similarity_scores, threshold):
    """
    Get the indices of the gm_list_edges with the highest similarity score 

    Args:
        similarity_scores (list): Similarity scores of one element of the SM with all elements of the GM
        threshold (int): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal

    Returns:
        list: List containing the indices of similarity_scores (therefore gm_list_edges) with the highest similarity 
    """
    
    max = 0 
    aimed_indices = []
    
    for i, similarity_score in enumerate(similarity_scores):
        
        #TODO: check for threshold and search for max --> List is used, as there could be more than 1 max
        # i.e. two exclusivegateways (x) on left side / two or more same tasks on left side
        if similarity_score > threshold and similarity_score >= max:
            if similarity_score == max:
                aimed_indices.append(i)
            else:
                aimed_indices = [i]
            max = similarity_score        
    return aimed_indices
             
def compare_models_em(sm, gm, weights, threshold):
    """
    Compare the two models Standard Model (SM) and Generated Model (GM) with the EdgeMatching algorithm.
    

    Args:
        sm (BPMN): The standard BPMN model (created by a human process modeler)
        gm (BPMN): The generated BPMN model (generated by the AI)
        weights (dict): Weights for the low level similarity to be applied (glove/BERT/syntactic)
        threshold (float): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal 
    """
    #format gm_list_edges correctly to compare with sm_list_edges
    gm_parents = create_gm_parents(gm.edges, gm.events, gm.tasks, gm.gateways)
    #print('GENERATED MODEL FORMATTED PARENTS ARE:')
    #print(gm_parents)
    
    #iterate over entire sm_list_edges 
    for i, sm_edge in enumerate(sm.edges):
        print('****************************')
        print(f'INDEX: {i} BEGINNING')
        print('****************************')
        
        print('LEFT/PARENT SIDE')
        aimed_indices_parent = []
        aimed_indices_child = []
        #first compare the left side of SM and GM list_edges
        check_index_access(sm_edge, 0)
        sm_parent = get_value(sm_edge[0], sm.events, sm.tasks, sm.gateways)
        
        #similarity function (cosine, syntactic, ...) can be replaced here
        similarity_scores = compute_similarity(sm_parent, gm_parents, weights)
        #the indices of the gm_list_edges where there is a match are stored in aimed_indices_parent
        aimed_indices_parent = get_aimed_indices(similarity_scores, threshold)
        
        #no match on left side of sm at sm_edge[i] and gm
        if len(aimed_indices_parent) == 0:
            continue
           
        print('****************************')
        print(f'Aimed index is {aimed_indices_parent}')
        print('****************************')
        
        print('RIGHT/CHILD SIDE:')
        check_index_access(sm_edge, 1)
        sm_child = get_value(sm_edge[1], sm.events, sm.tasks, sm.gateways)
        
        #TODO: to be replaced by respective similarity function
        gm_children = create_gm_children(gm.edges, gm.events, gm.tasks, gm.gateways, aimed_indices_parent)
        similarity_scores = compute_similarity(sm_child, gm_children, weights)
        aimed_indices_child = get_aimed_indices(similarity_scores, threshold)
        print('****************************')
        
        #find true positives
        for i_right in aimed_indices_child:
            check_index_access(aimed_indices_parent, i_right)
            
            #correct index of similar gm_edge
            gm_edge_index = aimed_indices_parent[i_right]
            #set true positives for sm and gm
            
            check_index_access(gm.edges, gm_edge_index)
            check_index_access(gm.edges[gm_edge_index], 0)
            check_index_access(gm.edges[gm_edge_index], 1)
            check_index_access(gm.edges[gm_edge_index], 2)
            check_index_access(sm_edge, 0)
            check_index_access(sm_edge, 1)
            check_index_access(sm_edge, 2)
            #the edge of the gm has no match yet (if it already has one, skip) AND the types of the matches must be equivalent (e.g. excl.gateway and parallelgateway are not the same!)
            if gm.edges[gm_edge_index][2] == 0 and get_type(sm_edge[0]) == get_type(gm.edges[gm_edge_index][0]) and get_type(sm_edge[1]) == get_type(gm.edges[gm_edge_index][1]):
                print(f'Type of sm left is {get_type(sm_edge[0])} and type of gm left is {get_type(gm.edges[gm_edge_index][0])}')
                print(f'Type of sm right is {get_type(sm_edge[1])} and type of gm right is {get_type(gm.edges[gm_edge_index][1])}')
                sm_edge[2] = 1
                gm.edges[gm_edge_index][2] = 1
                print(f'MARKED INDEX {i} of SM as TRUE POSITIVE!!!!')
                print(f'CORRESPONDING INDEX {gm_edge_index} OF GM TRUE POSITIVE!!!!!')
            #print('****************************')       
        print(f'INDEX: {i} ENDING')
        
    print('Final SM TUPLE:')
    print(sm.edges)
    
    print('Final GM TUPLE:')
    print(gm.edges)
    return


        
    